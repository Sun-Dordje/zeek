// This file is automatically generated from opcua.pac.


#ifdef __clang__
#pragma clang diagnostic ignored "-Wparentheses-equality"
#endif

#include "opcua_pac.h"

namespace binpac {







uint32 const READ_REQUEST = 629;
uint32 const READ_RESPONSE = 632;
uint32 const SECURE_CHANNEL_REQUEST = 446;
uint32 const SECURE_CHANNEL_RESPONSE = 449;
uint32 const PUBLISH_REQUEST = 824;
uint32 const PUBLISH_RESPONSE = 827;
uint32 const CLOSE_SECURE_CHANNEL_REQUEST = 450;
uint32 const CLOSE_SECURE_CHANNEL_RESPONSE = 453;
uint32 const BROWSE_REQUEST = 525;
uint32 const BROWSE_RESPONSE = 528;
uint32 const WRITE_REQUEST = 671;
uint32 const WRITE_RESPONSE = 674;
uint32 const CREATE_SUBSCR_REQUEST = 785;
uint32 const CREATE_SUBSCR_RESPONSE = 788;
uint32 const GET_ENDPOINTS_REQUEST = 428;
uint32 const GET_ENDPOINTS_RESPONSE = 431;
OPCUA_PDU::OPCUA_PDU(bool is_orig)
	{
	is_orig_ = is_orig;
	byteorder_ = bigendian;
	}

OPCUA_PDU::~OPCUA_PDU()
	{
	data_.free();
	}

int OPCUA_PDU::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data)
	{
	// Parse "data"
	int t_data_string_length;
	t_data_string_length = (t_end_of_data) - (t_begin_of_data);
	int t_data__size;
	t_data__size = t_data_string_length;
	// check for negative sizes
	if ( t_data_string_length < 0 )
	throw binpac::ExceptionInvalidStringLength("/home/stagiaire2019/Bureau/stage/t/zeek/src/analyzer/protocol/opcua/opcua-protocol.pac:36", t_data_string_length);
	data_.init(t_begin_of_data, t_data_string_length);
	// Evaluate 'let' and 'withinput' fields
	
	int t_OPCUA_PDU__size;
	const_byteptr const t_dataptr_after_data = t_begin_of_data + (t_data__size);
	BINPAC_ASSERT(t_dataptr_after_data <= t_end_of_data);
	t_OPCUA_PDU__size = t_dataptr_after_data - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_OPCUA_PDU__size) <= t_end_of_data);
	return t_OPCUA_PDU__size;
	}

QUALIFIED_NAME::QUALIFIED_NAME()
	{
	id_ = 0;
	len_ = 0;
	val_case_index_ = -1;
	}

QUALIFIED_NAME::~QUALIFIED_NAME()
	{
	switch ( val_case_index() )
		{
		case -1:
			// Clean up "e"
			{
			}
			break;
		case 0:
			// Clean up "f"
			{
			}
			break;
		default:
			// Clean up "name"
			{
			name_.free();
			}
			break;
		}
	}

int QUALIFIED_NAME::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, int t_byteorder)
	{
	// Checking out-of-bound for "QUALIFIED_NAME:len"
	if ( (t_begin_of_data + 2) + (4) > t_end_of_data || (t_begin_of_data + 2) + (4) < (t_begin_of_data + 2) )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("QUALIFIED_NAME:len",
			(2) + (4), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "id"
	id_ = FixByteOrder(t_byteorder, *((uint16 const *) (t_begin_of_data)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "len"
	len_ = FixByteOrder(littleendian, *((uint32 const *) ((t_begin_of_data + 2))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "val"
	int t_val__size;
	val_case_index_ =  ( len() ) ;
	switch ( val_case_index() )
		{
		case -1:
			// Parse "e"
			{
			// Evaluate 'let' and 'withinput' fields
			t_val__size = 0;
			}
			break;
		case 0:
			// Parse "f"
			{
			// Evaluate 'let' and 'withinput' fields
			t_val__size = 0;
			}
			break;
		default:
			// Parse "name"
			{
			int t_name__size;
			t_name__size = len();
			// Checking out-of-bound for "QUALIFIED_NAME:name"
			if ( (t_begin_of_data + 6) + (t_name__size) > t_end_of_data || (t_begin_of_data + 6) + (t_name__size) < (t_begin_of_data + 6) )
				{
				// Handle out-of-bound condition
				throw binpac::ExceptionOutOfBound("QUALIFIED_NAME:name",
					(6) + (t_name__size), 
					(t_end_of_data) - (t_begin_of_data));
				}
			{
			// Setting t_end_of_data with &length
			const_byteptr t_end_of_data = (t_begin_of_data + 6) + t_name__size;
			int t_name_string_length;
			t_name_string_length = len();
			// check for negative sizes
			if ( t_name_string_length < 0 )
			throw binpac::ExceptionInvalidStringLength("/home/stagiaire2019/Bureau/stage/t/zeek/src/analyzer/protocol/opcua/opcua-protocol.pac:45", t_name_string_length);
			name_.init((t_begin_of_data + 6), t_name_string_length);
			// Evaluate 'let' and 'withinput' fields
			}
			t_val__size = t_name__size;
			}
			break;
		}
	// Evaluate 'let' and 'withinput' fields
	
	int t_QUALIFIED_NAME__size;
	const_byteptr const t_dataptr_after_val = (t_begin_of_data + 6) + (t_val__size);
	BINPAC_ASSERT(t_dataptr_after_val <= t_end_of_data);
	t_QUALIFIED_NAME__size = t_dataptr_after_val - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_QUALIFIED_NAME__size) <= t_end_of_data);
	return t_QUALIFIED_NAME__size;
	}

MESSAGE::MESSAGE()
	{
	type_id_ = 0;
	type_id__elem_ = 0;
	content_case_index_ = -1;
	open_secure_channel_request_ = 0;
	open_secure_channel_response_ = 0;
	publish_request_ = 0;
	publish_response_ = 0;
	close_secure_channel_request_ = 0;
	close_secure_channel_response_ = 0;
	browse_request_ = 0;
	browse_response_ = 0;
	read_request_ = 0;
	read_response_ = 0;
	write_request_ = 0;
	write_response_ = 0;
	subscription_request_ = 0;
	subscription_response_ = 0;
	get_endpoints_request_ = 0;
	get_endpoints_response_ = 0;
	}

MESSAGE::~MESSAGE()
	{
	delete type_id_;
	switch ( content_case_index() )
		{
		case 446:
			// Clean up "open_secure_channel_request"
			{
			delete open_secure_channel_request_;
			open_secure_channel_request_ = 0;
			}
			break;
		case 449:
			// Clean up "open_secure_channel_response"
			{
			delete open_secure_channel_response_;
			open_secure_channel_response_ = 0;
			}
			break;
		case 824:
			// Clean up "publish_request"
			{
			delete publish_request_;
			publish_request_ = 0;
			}
			break;
		case 827:
			// Clean up "publish_response"
			{
			delete publish_response_;
			publish_response_ = 0;
			}
			break;
		case 450:
			// Clean up "close_secure_channel_request"
			{
			delete close_secure_channel_request_;
			close_secure_channel_request_ = 0;
			}
			break;
		case 453:
			// Clean up "close_secure_channel_response"
			{
			delete close_secure_channel_response_;
			close_secure_channel_response_ = 0;
			}
			break;
		case 525:
			// Clean up "browse_request"
			{
			delete browse_request_;
			browse_request_ = 0;
			}
			break;
		case 528:
			// Clean up "browse_response"
			{
			delete browse_response_;
			browse_response_ = 0;
			}
			break;
		case 629:
			// Clean up "read_request"
			{
			delete read_request_;
			read_request_ = 0;
			}
			break;
		case 632:
			// Clean up "read_response"
			{
			delete read_response_;
			read_response_ = 0;
			}
			break;
		case 671:
			// Clean up "write_request"
			{
			delete write_request_;
			write_request_ = 0;
			}
			break;
		case 674:
			// Clean up "write_response"
			{
			delete write_response_;
			write_response_ = 0;
			}
			break;
		case 785:
			// Clean up "subscription_request"
			{
			delete subscription_request_;
			subscription_request_ = 0;
			}
			break;
		case 788:
			// Clean up "subscription_response"
			{
			delete subscription_response_;
			subscription_response_ = 0;
			}
			break;
		case 428:
			// Clean up "get_endpoints_request"
			{
			delete get_endpoints_request_;
			get_endpoints_request_ = 0;
			}
			break;
		case 431:
			// Clean up "get_endpoints_response"
			{
			delete get_endpoints_response_;
			get_endpoints_response_ = 0;
			}
			break;
		default:
			// Clean up "not_parsed"
			{
			}
			break;
		}
	}

int MESSAGE::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, int t_byteorder)
	{
	// Checking out-of-bound for "MESSAGE:type_id"
	if ( t_begin_of_data + (4) > t_end_of_data || t_begin_of_data + (4) < t_begin_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("MESSAGE:type_id",
			(0) + (4), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "type_id"
	int t_type_id__arraylength;
	t_type_id__arraylength = 0;
	t_type_id__arraylength = 4;
	if ( t_begin_of_data + t_type_id__arraylength > t_end_of_data + 1 )
		{
		t_type_id__arraylength = t_end_of_data - t_begin_of_data + 1;
		}
	if ( t_type_id__arraylength < 0 )
		{
		t_type_id__arraylength = 0;
		}
	type_id__elem_ = 0;
	int t_type_id__elem__it;
	t_type_id__elem__it = 0;
	type_id_ = new vector<uint8>;
	type_id_->reserve(t_type_id__arraylength);
	const_byteptr t_type_id__elem__dataptr = t_begin_of_data;
	for (; t_type_id__elem__it < t_type_id__arraylength; ++t_type_id__elem__it)
		{
		// Check &until(type_id__elem__dataptr >= end_of_data)
		if ( t_type_id__elem__dataptr >= t_end_of_data )
			{
			goto end_of_type_id;
			}
		type_id__elem_ = *((uint8 const *) (t_type_id__elem__dataptr));
		// Evaluate 'let' and 'withinput' fields
		type_id_->push_back(type_id__elem_);
		t_type_id__elem__dataptr += 1;
		BINPAC_ASSERT(t_type_id__elem__dataptr <= t_end_of_data);
		}
end_of_type_id: ;
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "content"
	int t_content__size;
	content_case_index_ =  ( (*(type_id()))[3] |  ( (*(type_id()))[2] << 8 )  ) ;
	switch ( content_case_index() )
		{
		case 446:
			// Parse "open_secure_channel_request"
			{
			open_secure_channel_request_ = new OPEN_SECURE_CHANNEL_REQUEST();
			open_secure_channel_request_->Parse((t_begin_of_data + 4), t_end_of_data, t_byteorder);
			// Evaluate 'let' and 'withinput' fields
			t_content__size = 55;
			}
			break;
		case 449:
			// Parse "open_secure_channel_response"
			{
			open_secure_channel_response_ = new OPEN_SECURE_CHANNEL_RESPONSE();
			open_secure_channel_response_->Parse((t_begin_of_data + 4), t_end_of_data, t_byteorder);
			// Evaluate 'let' and 'withinput' fields
			t_content__size = 45;
			}
			break;
		case 824:
			// Parse "publish_request"
			{
			publish_request_ = new OPCUA_PUBLISH_REQUEST();
			publish_request_->Parse((t_begin_of_data + 4), t_end_of_data, t_byteorder);
			// Evaluate 'let' and 'withinput' fields
			t_content__size = 41;
			}
			break;
		case 827:
			// Parse "publish_response"
			{
			publish_response_ = new OPCUA_PUBLISH_RESPONSE();
			publish_response_->Parse((t_begin_of_data + 4), t_end_of_data, t_byteorder);
			// Evaluate 'let' and 'withinput' fields
			t_content__size = 68;
			}
			break;
		case 450:
			// Parse "close_secure_channel_request"
			{
			close_secure_channel_request_ = new OPCUA_CLOSE_SECURE_CHANNEL_REQUEST();
			close_secure_channel_request_->Parse((t_begin_of_data + 4), t_end_of_data, t_byteorder);
			// Evaluate 'let' and 'withinput' fields
			t_content__size = 37;
			}
			break;
		case 453:
			// Parse "close_secure_channel_response"
			{
			close_secure_channel_response_ = new OPCUA_CLOSE_SECURE_CHANNEL_RESPONSE();
			close_secure_channel_response_->Parse((t_begin_of_data + 4), t_end_of_data, t_byteorder);
			// Evaluate 'let' and 'withinput' fields
			t_content__size = 27;
			}
			break;
		case 525:
			// Parse "browse_request"
			{
			browse_request_ = new OPCUA_BROWSE_REQUEST();
			browse_request_->Parse((t_begin_of_data + 4), t_end_of_data, t_byteorder);
			// Evaluate 'let' and 'withinput' fields
			t_content__size = 63;
			}
			break;
		case 528:
			// Parse "browse_response"
			{
			browse_response_ = new OPCUA_BROWSE_RESPONSE();
			browse_response_->Parse((t_begin_of_data + 4), t_end_of_data, t_byteorder);
			// Evaluate 'let' and 'withinput' fields
			t_content__size = 43;
			}
			break;
		case 629:
			// Parse "read_request"
			{
			read_request_ = new OPCUA_READ_REQUEST();
			read_request_->Parse((t_begin_of_data + 4), t_end_of_data, t_byteorder);
			// Evaluate 'let' and 'withinput' fields
			t_content__size = 61;
			}
			break;
		case 632:
			// Parse "read_response"
			{
			read_response_ = new OPCUA_READ_RESPONSE();
			read_response_->Parse((t_begin_of_data + 4), t_end_of_data, t_byteorder);
			// Evaluate 'let' and 'withinput' fields
			t_content__size = 43;
			}
			break;
		case 671:
			// Parse "write_request"
			{
			write_request_ = new OPCUA_WRITE_REQUEST();
			write_request_->Parse((t_begin_of_data + 4), t_end_of_data, t_byteorder);
			// Evaluate 'let' and 'withinput' fields
			t_content__size = 45;
			}
			break;
		case 674:
			// Parse "write_response"
			{
			write_response_ = new OPCUA_WRITE_RESPONSE();
			write_response_->Parse((t_begin_of_data + 4), t_end_of_data, t_byteorder);
			// Evaluate 'let' and 'withinput' fields
			t_content__size = 43;
			}
			break;
		case 785:
			// Parse "subscription_request"
			{
			subscription_request_ = new OPCUA_CREATE_SUBSCR_REQUEST();
			subscription_request_->Parse((t_begin_of_data + 4), t_end_of_data, t_byteorder);
			// Evaluate 'let' and 'withinput' fields
			t_content__size = 59;
			}
			break;
		case 788:
			// Parse "subscription_response"
			{
			subscription_response_ = new OPCUA_CREATE_SUBSCR_RESPONSE();
			subscription_response_->Parse((t_begin_of_data + 4), t_end_of_data, t_byteorder);
			// Evaluate 'let' and 'withinput' fields
			t_content__size = 43;
			}
			break;
		case 428:
			// Parse "get_endpoints_request"
			{
			get_endpoints_request_ = new OPCUA_GET_ENDPOINTS_REQUEST();
			get_endpoints_request_->Parse((t_begin_of_data + 4), t_end_of_data, t_byteorder);
			// Evaluate 'let' and 'withinput' fields
			t_content__size = 57;
			}
			break;
		case 431:
			// Parse "get_endpoints_response"
			{
			get_endpoints_response_ = new OPCUA_GET_ENDPOINTS_RESPONSE();
			get_endpoints_response_->Parse((t_begin_of_data + 4), t_end_of_data, t_byteorder);
			// Evaluate 'let' and 'withinput' fields
			t_content__size = 35;
			}
			break;
		default:
			// Parse "not_parsed"
			{
			// Evaluate 'let' and 'withinput' fields
			t_content__size = 0;
			}
			break;
		}
	// Evaluate 'let' and 'withinput' fields
	
	int t_MESSAGE__size;
	const_byteptr const t_dataptr_after_content = (t_begin_of_data + 4) + (t_content__size);
	BINPAC_ASSERT(t_dataptr_after_content <= t_end_of_data);
	t_MESSAGE__size = t_dataptr_after_content - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_MESSAGE__size) <= t_end_of_data);
	return t_MESSAGE__size;
	}

REQUEST_HEADER::REQUEST_HEADER()
	{
	authentication_token_ = 0;
	timestamp_ = 0;
	request_handle_ = 0;
	return_diagnostics_ = 0;
	audit_entry_id_ = 0;
	timeout_hint_ = 0;
	additional_header_ = 0;
	additional_header__elem_ = 0;
	}

REQUEST_HEADER::~REQUEST_HEADER()
	{
	delete authentication_token_;
	authentication_token_ = 0;
	delete additional_header_;
	}

int REQUEST_HEADER::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, int t_byteorder)
	{
	// Checking out-of-bound for "REQUEST_HEADER"
	if ( t_begin_of_data + (37) > t_end_of_data || t_begin_of_data + (37) < t_begin_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("REQUEST_HEADER",
			(0) + (37), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "authentication_token"
	authentication_token_ = new NODE_ID();
	authentication_token_->Parse(t_begin_of_data, t_end_of_data, t_byteorder);
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "timestamp"
	timestamp_ = FixByteOrder(t_byteorder, *((uint64 const *) ((t_begin_of_data + 10))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "request_handle"
	request_handle_ = FixByteOrder(t_byteorder, *((uint32 const *) ((t_begin_of_data + 18))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "return_diagnostics"
	return_diagnostics_ = FixByteOrder(t_byteorder, *((uint32 const *) ((t_begin_of_data + 22))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "audit_entry_id"
	audit_entry_id_ = FixByteOrder(t_byteorder, *((uint32 const *) ((t_begin_of_data + 26))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "timeout_hint"
	timeout_hint_ = FixByteOrder(t_byteorder, *((uint32 const *) ((t_begin_of_data + 30))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "additional_header"
	int t_additional_header__arraylength;
	t_additional_header__arraylength = 0;
	t_additional_header__arraylength = 3;
	if ( t_begin_of_data + t_additional_header__arraylength > t_end_of_data + 1 )
		{
		t_additional_header__arraylength = t_end_of_data - t_begin_of_data + 1;
		}
	if ( t_additional_header__arraylength < 0 )
		{
		t_additional_header__arraylength = 0;
		}
	additional_header__elem_ = 0;
	int t_additional_header__elem__it;
	t_additional_header__elem__it = 0;
	additional_header_ = new vector<uint8>;
	additional_header_->reserve(t_additional_header__arraylength);
	const_byteptr t_additional_header__elem__dataptr = (t_begin_of_data + 34);
	for (; t_additional_header__elem__it < t_additional_header__arraylength; ++t_additional_header__elem__it)
		{
		// Check &until(additional_header__elem__dataptr >= end_of_data)
		if ( t_additional_header__elem__dataptr >= t_end_of_data )
			{
			goto end_of_additional_header;
			}
		additional_header__elem_ = *((uint8 const *) (t_additional_header__elem__dataptr));
		// Evaluate 'let' and 'withinput' fields
		additional_header_->push_back(additional_header__elem_);
		t_additional_header__elem__dataptr += 1;
		BINPAC_ASSERT(t_additional_header__elem__dataptr <= t_end_of_data);
		}
end_of_additional_header: ;
	// Evaluate 'let' and 'withinput' fields
	
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (37) <= t_end_of_data);
	return 37;
	}

RESPONSE_HEADER::RESPONSE_HEADER()
	{
	timestamp_ = 0;
	request_handle_ = 0;
	service_result_ = 0;
	service_diagnostics_flag_ = 0;
	string_table_ = 0;
	additional_header_ = 0;
	additional_header__elem_ = 0;
	}

RESPONSE_HEADER::~RESPONSE_HEADER()
	{
	delete additional_header_;
	}

int RESPONSE_HEADER::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, int t_byteorder)
	{
	// Checking out-of-bound for "RESPONSE_HEADER"
	if ( t_begin_of_data + (27) > t_end_of_data || t_begin_of_data + (27) < t_begin_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("RESPONSE_HEADER",
			(0) + (27), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "timestamp"
	timestamp_ = FixByteOrder(t_byteorder, *((uint64 const *) (t_begin_of_data)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "request_handle"
	request_handle_ = FixByteOrder(t_byteorder, *((uint32 const *) ((t_begin_of_data + 8))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "service_result"
	service_result_ = FixByteOrder(t_byteorder, *((uint32 const *) ((t_begin_of_data + 12))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "service_diagnostics_flag"
	service_diagnostics_flag_ = FixByteOrder(t_byteorder, *((uint32 const *) ((t_begin_of_data + 16))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "string_table"
	string_table_ = FixByteOrder(t_byteorder, *((uint32 const *) ((t_begin_of_data + 20))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "additional_header"
	int t_additional_header__arraylength;
	t_additional_header__arraylength = 0;
	t_additional_header__arraylength = 3;
	if ( t_begin_of_data + t_additional_header__arraylength > t_end_of_data + 1 )
		{
		t_additional_header__arraylength = t_end_of_data - t_begin_of_data + 1;
		}
	if ( t_additional_header__arraylength < 0 )
		{
		t_additional_header__arraylength = 0;
		}
	additional_header__elem_ = 0;
	int t_additional_header__elem__it;
	t_additional_header__elem__it = 0;
	additional_header_ = new vector<uint8>;
	additional_header_->reserve(t_additional_header__arraylength);
	const_byteptr t_additional_header__elem__dataptr = (t_begin_of_data + 24);
	for (; t_additional_header__elem__it < t_additional_header__arraylength; ++t_additional_header__elem__it)
		{
		// Check &until(additional_header__elem__dataptr >= end_of_data)
		if ( t_additional_header__elem__dataptr >= t_end_of_data )
			{
			goto end_of_additional_header;
			}
		additional_header__elem_ = *((uint8 const *) (t_additional_header__elem__dataptr));
		// Evaluate 'let' and 'withinput' fields
		additional_header_->push_back(additional_header__elem_);
		t_additional_header__elem__dataptr += 1;
		BINPAC_ASSERT(t_additional_header__elem__dataptr <= t_end_of_data);
		}
end_of_additional_header: ;
	// Evaluate 'let' and 'withinput' fields
	
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (27) <= t_end_of_data);
	return 27;
	}

OPEN_SECURE_CHANNEL_REQUEST::OPEN_SECURE_CHANNEL_REQUEST()
	{
	header_ = 0;
	client_protocol_version_ = 0;
	security_token_request_type_ = 0;
	message_security_mode_ = 0;
	client_nonce_ = 0;
	request_lifetime_ = 0;
	}

OPEN_SECURE_CHANNEL_REQUEST::~OPEN_SECURE_CHANNEL_REQUEST()
	{
	delete header_;
	header_ = 0;
	}

int OPEN_SECURE_CHANNEL_REQUEST::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, int t_byteorder)
	{
	// Checking out-of-bound for "OPEN_SECURE_CHANNEL_REQUEST"
	if ( t_begin_of_data + (55) > t_end_of_data || t_begin_of_data + (55) < t_begin_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("OPEN_SECURE_CHANNEL_REQUEST",
			(0) + (55), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "header"
	header_ = new REQUEST_HEADER();
	header_->Parse(t_begin_of_data, t_end_of_data, t_byteorder);
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "client_protocol_version"
	client_protocol_version_ = FixByteOrder(t_byteorder, *((uint32 const *) ((t_begin_of_data + 37))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "security_token_request_type"
	security_token_request_type_ = FixByteOrder(t_byteorder, *((uint32 const *) ((t_begin_of_data + 41))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "message_security_mode"
	message_security_mode_ = FixByteOrder(t_byteorder, *((uint32 const *) ((t_begin_of_data + 45))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "client_nonce"
	client_nonce_ = FixByteOrder(t_byteorder, *((uint16 const *) ((t_begin_of_data + 49))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "request_lifetime"
	request_lifetime_ = FixByteOrder(t_byteorder, *((uint32 const *) ((t_begin_of_data + 51))));
	// Evaluate 'let' and 'withinput' fields
	
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (55) <= t_end_of_data);
	return 55;
	}

OPEN_SECURE_CHANNEL_RESPONSE::OPEN_SECURE_CHANNEL_RESPONSE()
	{
	header_ = 0;
	client_protocol_version_ = 0;
	security_token_request_type_ = 0;
	message_security_mode_ = 0;
	client_nonce_ = 0;
	request_lifetime_ = 0;
	}

OPEN_SECURE_CHANNEL_RESPONSE::~OPEN_SECURE_CHANNEL_RESPONSE()
	{
	delete header_;
	header_ = 0;
	}

int OPEN_SECURE_CHANNEL_RESPONSE::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, int t_byteorder)
	{
	// Checking out-of-bound for "OPEN_SECURE_CHANNEL_RESPONSE"
	if ( t_begin_of_data + (45) > t_end_of_data || t_begin_of_data + (45) < t_begin_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("OPEN_SECURE_CHANNEL_RESPONSE",
			(0) + (45), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "header"
	header_ = new RESPONSE_HEADER();
	header_->Parse(t_begin_of_data, t_end_of_data, t_byteorder);
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "client_protocol_version"
	client_protocol_version_ = FixByteOrder(t_byteorder, *((uint32 const *) ((t_begin_of_data + 27))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "security_token_request_type"
	security_token_request_type_ = FixByteOrder(t_byteorder, *((uint32 const *) ((t_begin_of_data + 31))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "message_security_mode"
	message_security_mode_ = FixByteOrder(t_byteorder, *((uint32 const *) ((t_begin_of_data + 35))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "client_nonce"
	client_nonce_ = FixByteOrder(t_byteorder, *((uint16 const *) ((t_begin_of_data + 39))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "request_lifetime"
	request_lifetime_ = FixByteOrder(t_byteorder, *((uint32 const *) ((t_begin_of_data + 41))));
	// Evaluate 'let' and 'withinput' fields
	
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (45) <= t_end_of_data);
	return 45;
	}

OPCUA_PUBLISH_REQUEST::OPCUA_PUBLISH_REQUEST()
	{
	header_ = 0;
	subscription_ack_ = 0;
	}

OPCUA_PUBLISH_REQUEST::~OPCUA_PUBLISH_REQUEST()
	{
	delete header_;
	header_ = 0;
	}

int OPCUA_PUBLISH_REQUEST::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, int t_byteorder)
	{
	// Checking out-of-bound for "OPCUA_PUBLISH_REQUEST"
	if ( t_begin_of_data + (41) > t_end_of_data || t_begin_of_data + (41) < t_begin_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("OPCUA_PUBLISH_REQUEST",
			(0) + (41), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "header"
	header_ = new REQUEST_HEADER();
	header_->Parse(t_begin_of_data, t_end_of_data, t_byteorder);
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "subscription_ack"
	subscription_ack_ = FixByteOrder(t_byteorder, *((uint32 const *) ((t_begin_of_data + 37))));
	// Evaluate 'let' and 'withinput' fields
	
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (41) <= t_end_of_data);
	return 41;
	}

OPCUA_CLOSE_SECURE_CHANNEL_REQUEST::OPCUA_CLOSE_SECURE_CHANNEL_REQUEST()
	{
	header_ = 0;
	}

OPCUA_CLOSE_SECURE_CHANNEL_REQUEST::~OPCUA_CLOSE_SECURE_CHANNEL_REQUEST()
	{
	delete header_;
	header_ = 0;
	}

int OPCUA_CLOSE_SECURE_CHANNEL_REQUEST::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, int t_byteorder)
	{
	// Checking out-of-bound for "OPCUA_CLOSE_SECURE_CHANNEL_REQUEST"
	if ( t_begin_of_data + (37) > t_end_of_data || t_begin_of_data + (37) < t_begin_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("OPCUA_CLOSE_SECURE_CHANNEL_REQUEST",
			(0) + (37), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "header"
	header_ = new REQUEST_HEADER();
	header_->Parse(t_begin_of_data, t_end_of_data, t_byteorder);
	// Evaluate 'let' and 'withinput' fields
	
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (37) <= t_end_of_data);
	return 37;
	}

OPCUA_CLOSE_SECURE_CHANNEL_RESPONSE::OPCUA_CLOSE_SECURE_CHANNEL_RESPONSE()
	{
	header_ = 0;
	}

OPCUA_CLOSE_SECURE_CHANNEL_RESPONSE::~OPCUA_CLOSE_SECURE_CHANNEL_RESPONSE()
	{
	delete header_;
	header_ = 0;
	}

int OPCUA_CLOSE_SECURE_CHANNEL_RESPONSE::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, int t_byteorder)
	{
	// Checking out-of-bound for "OPCUA_CLOSE_SECURE_CHANNEL_RESPONSE"
	if ( t_begin_of_data + (27) > t_end_of_data || t_begin_of_data + (27) < t_begin_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("OPCUA_CLOSE_SECURE_CHANNEL_RESPONSE",
			(0) + (27), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "header"
	header_ = new RESPONSE_HEADER();
	header_->Parse(t_begin_of_data, t_end_of_data, t_byteorder);
	// Evaluate 'let' and 'withinput' fields
	
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (27) <= t_end_of_data);
	return 27;
	}

OPCUA_BROWSE_REQUEST::OPCUA_BROWSE_REQUEST()
	{
	header_ = 0;
	view_ = 0;
	requested_max_references_per_node_ = 0;
	}

OPCUA_BROWSE_REQUEST::~OPCUA_BROWSE_REQUEST()
	{
	delete header_;
	header_ = 0;
	delete view_;
	view_ = 0;
	}

int OPCUA_BROWSE_REQUEST::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, int t_byteorder)
	{
	// Checking out-of-bound for "OPCUA_BROWSE_REQUEST"
	if ( t_begin_of_data + (63) > t_end_of_data || t_begin_of_data + (63) < t_begin_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("OPCUA_BROWSE_REQUEST",
			(0) + (63), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "header"
	header_ = new REQUEST_HEADER();
	header_->Parse(t_begin_of_data, t_end_of_data, t_byteorder);
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "view"
	view_ = new VIEW_DESCRIPTION();
	view_->Parse((t_begin_of_data + 37), t_end_of_data, t_byteorder);
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "requested_max_references_per_node"
	requested_max_references_per_node_ = FixByteOrder(t_byteorder, *((uint32 const *) ((t_begin_of_data + 59))));
	// Evaluate 'let' and 'withinput' fields
	
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (63) <= t_end_of_data);
	return 63;
	}

OPCUA_BROWSE_RESPONSE::OPCUA_BROWSE_RESPONSE()
	{
	header_ = 0;
	results_ = 0;
	diagnostic_info_collection_ = 0;
	}

OPCUA_BROWSE_RESPONSE::~OPCUA_BROWSE_RESPONSE()
	{
	delete header_;
	header_ = 0;
	}

int OPCUA_BROWSE_RESPONSE::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, int t_byteorder)
	{
	// Checking out-of-bound for "OPCUA_BROWSE_RESPONSE"
	if ( t_begin_of_data + (43) > t_end_of_data || t_begin_of_data + (43) < t_begin_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("OPCUA_BROWSE_RESPONSE",
			(0) + (43), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "header"
	header_ = new RESPONSE_HEADER();
	header_->Parse(t_begin_of_data, t_end_of_data, t_byteorder);
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "results"
	results_ = FixByteOrder(t_byteorder, *((uint64 const *) ((t_begin_of_data + 27))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "diagnostic_info_collection"
	diagnostic_info_collection_ = FixByteOrder(t_byteorder, *((uint64 const *) ((t_begin_of_data + 35))));
	// Evaluate 'let' and 'withinput' fields
	
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (43) <= t_end_of_data);
	return 43;
	}

OPCUA_PUBLISH_RESPONSE::OPCUA_PUBLISH_RESPONSE()
	{
	header_ = 0;
	subscription_id_ = 0;
	available_sequence_numbers_ = 0;
	more_notifications_ = 0;
	notification_message_ = 0;
	status_code_collection_ = 0;
	diagnostic_info_collection_ = 0;
	}

OPCUA_PUBLISH_RESPONSE::~OPCUA_PUBLISH_RESPONSE()
	{
	delete header_;
	header_ = 0;
	}

int OPCUA_PUBLISH_RESPONSE::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, int t_byteorder)
	{
	// Checking out-of-bound for "OPCUA_PUBLISH_RESPONSE"
	if ( t_begin_of_data + (68) > t_end_of_data || t_begin_of_data + (68) < t_begin_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("OPCUA_PUBLISH_RESPONSE",
			(0) + (68), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "header"
	header_ = new RESPONSE_HEADER();
	header_->Parse(t_begin_of_data, t_end_of_data, t_byteorder);
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "subscription_id"
	subscription_id_ = FixByteOrder(t_byteorder, *((uint64 const *) ((t_begin_of_data + 27))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "available_sequence_numbers"
	available_sequence_numbers_ = FixByteOrder(t_byteorder, *((uint64 const *) ((t_begin_of_data + 35))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "more_notifications"
	more_notifications_ = *((uint8 const *) ((t_begin_of_data + 43)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "notification_message"
	notification_message_ = FixByteOrder(t_byteorder, *((uint64 const *) ((t_begin_of_data + 44))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "status_code_collection"
	status_code_collection_ = FixByteOrder(t_byteorder, *((uint64 const *) ((t_begin_of_data + 52))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "diagnostic_info_collection"
	diagnostic_info_collection_ = FixByteOrder(t_byteorder, *((uint64 const *) ((t_begin_of_data + 60))));
	// Evaluate 'let' and 'withinput' fields
	
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (68) <= t_end_of_data);
	return 68;
	}

NOTIFICATION_MESSAGE::NOTIFICATION_MESSAGE()
	{
	sequence_number_ = 0;
	publish_time_ = 0;
	notification_data_ = 0;
	}

NOTIFICATION_MESSAGE::~NOTIFICATION_MESSAGE()
	{
	}

int NOTIFICATION_MESSAGE::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, int t_byteorder)
	{
	// Checking out-of-bound for "NOTIFICATION_MESSAGE"
	if ( t_begin_of_data + (20) > t_end_of_data || t_begin_of_data + (20) < t_begin_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("NOTIFICATION_MESSAGE",
			(0) + (20), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "sequence_number"
	sequence_number_ = FixByteOrder(t_byteorder, *((uint32 const *) (t_begin_of_data)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "publish_time"
	publish_time_ = FixByteOrder(t_byteorder, *((uint64 const *) ((t_begin_of_data + 4))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "notification_data"
	notification_data_ = FixByteOrder(t_byteorder, *((uint64 const *) ((t_begin_of_data + 12))));
	// Evaluate 'let' and 'withinput' fields
	
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (20) <= t_end_of_data);
	return 20;
	}

VIEW_DESCRIPTION::VIEW_DESCRIPTION()
	{
	view_id_ = 0;
	time_stamp_ = 0;
	view_version_ = 0;
	}

VIEW_DESCRIPTION::~VIEW_DESCRIPTION()
	{
	delete view_id_;
	view_id_ = 0;
	}

int VIEW_DESCRIPTION::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, int t_byteorder)
	{
	// Checking out-of-bound for "VIEW_DESCRIPTION"
	if ( t_begin_of_data + (22) > t_end_of_data || t_begin_of_data + (22) < t_begin_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("VIEW_DESCRIPTION",
			(0) + (22), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "view_id"
	view_id_ = new NODE_ID();
	view_id_->Parse(t_begin_of_data, t_end_of_data, t_byteorder);
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "time_stamp"
	time_stamp_ = FixByteOrder(t_byteorder, *((uint64 const *) ((t_begin_of_data + 10))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "view_version"
	view_version_ = FixByteOrder(t_byteorder, *((uint32 const *) ((t_begin_of_data + 18))));
	// Evaluate 'let' and 'withinput' fields
	
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (22) <= t_end_of_data);
	return 22;
	}

OPCUA_READ_REQUEST::OPCUA_READ_REQUEST()
	{
	header_ = 0;
	max_age_ = 0;
	time_stamp_ = 0;
	nodetoread_ = 0;
	}

OPCUA_READ_REQUEST::~OPCUA_READ_REQUEST()
	{
	delete header_;
	header_ = 0;
	}

int OPCUA_READ_REQUEST::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, int t_byteorder)
	{
	// Checking out-of-bound for "OPCUA_READ_REQUEST"
	if ( t_begin_of_data + (61) > t_end_of_data || t_begin_of_data + (61) < t_begin_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("OPCUA_READ_REQUEST",
			(0) + (61), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "header"
	header_ = new REQUEST_HEADER();
	header_->Parse(t_begin_of_data, t_end_of_data, t_byteorder);
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "max_age"
	max_age_ = FixByteOrder(t_byteorder, *((uint64 const *) ((t_begin_of_data + 37))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "time_stamp"
	time_stamp_ = FixByteOrder(t_byteorder, *((uint64 const *) ((t_begin_of_data + 45))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "nodetoread"
	nodetoread_ = FixByteOrder(t_byteorder, *((uint64 const *) ((t_begin_of_data + 53))));
	// Evaluate 'let' and 'withinput' fields
	
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (61) <= t_end_of_data);
	return 61;
	}

OPCUA_READ_RESPONSE::OPCUA_READ_RESPONSE()
	{
	header_ = 0;
	results_ = 0;
	diagnostic_info_collection_ = 0;
	}

OPCUA_READ_RESPONSE::~OPCUA_READ_RESPONSE()
	{
	delete header_;
	header_ = 0;
	}

int OPCUA_READ_RESPONSE::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, int t_byteorder)
	{
	// Checking out-of-bound for "OPCUA_READ_RESPONSE"
	if ( t_begin_of_data + (43) > t_end_of_data || t_begin_of_data + (43) < t_begin_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("OPCUA_READ_RESPONSE",
			(0) + (43), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "header"
	header_ = new RESPONSE_HEADER();
	header_->Parse(t_begin_of_data, t_end_of_data, t_byteorder);
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "results"
	results_ = FixByteOrder(t_byteorder, *((uint64 const *) ((t_begin_of_data + 27))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "diagnostic_info_collection"
	diagnostic_info_collection_ = FixByteOrder(t_byteorder, *((uint64 const *) ((t_begin_of_data + 35))));
	// Evaluate 'let' and 'withinput' fields
	
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (43) <= t_end_of_data);
	return 43;
	}

OPCUA_WRITE_REQUEST::OPCUA_WRITE_REQUEST()
	{
	header_ = 0;
	nodes_to_write_ = 0;
	}

OPCUA_WRITE_REQUEST::~OPCUA_WRITE_REQUEST()
	{
	delete header_;
	header_ = 0;
	}

int OPCUA_WRITE_REQUEST::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, int t_byteorder)
	{
	// Checking out-of-bound for "OPCUA_WRITE_REQUEST"
	if ( t_begin_of_data + (45) > t_end_of_data || t_begin_of_data + (45) < t_begin_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("OPCUA_WRITE_REQUEST",
			(0) + (45), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "header"
	header_ = new REQUEST_HEADER();
	header_->Parse(t_begin_of_data, t_end_of_data, t_byteorder);
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "nodes_to_write"
	nodes_to_write_ = FixByteOrder(t_byteorder, *((uint64 const *) ((t_begin_of_data + 37))));
	// Evaluate 'let' and 'withinput' fields
	
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (45) <= t_end_of_data);
	return 45;
	}

OPCUA_WRITE_RESPONSE::OPCUA_WRITE_RESPONSE()
	{
	header_ = 0;
	results_ = 0;
	diagnostic_info_collection_ = 0;
	}

OPCUA_WRITE_RESPONSE::~OPCUA_WRITE_RESPONSE()
	{
	delete header_;
	header_ = 0;
	}

int OPCUA_WRITE_RESPONSE::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, int t_byteorder)
	{
	// Checking out-of-bound for "OPCUA_WRITE_RESPONSE"
	if ( t_begin_of_data + (43) > t_end_of_data || t_begin_of_data + (43) < t_begin_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("OPCUA_WRITE_RESPONSE",
			(0) + (43), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "header"
	header_ = new RESPONSE_HEADER();
	header_->Parse(t_begin_of_data, t_end_of_data, t_byteorder);
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "results"
	results_ = FixByteOrder(t_byteorder, *((uint64 const *) ((t_begin_of_data + 27))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "diagnostic_info_collection"
	diagnostic_info_collection_ = FixByteOrder(t_byteorder, *((uint64 const *) ((t_begin_of_data + 35))));
	// Evaluate 'let' and 'withinput' fields
	
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (43) <= t_end_of_data);
	return 43;
	}

OPCUA_CREATE_SUBSCR_REQUEST::OPCUA_CREATE_SUBSCR_REQUEST()
	{
	header_ = 0;
	requested_publishing_interval_ = 0;
	requested_lifetime_count_ = 0;
	requested_max_keep_alive_count_ = 0;
	max_notifications_per_publish_ = 0;
	publishing_enabled_ = 0;
	priority_ = 0;
	}

OPCUA_CREATE_SUBSCR_REQUEST::~OPCUA_CREATE_SUBSCR_REQUEST()
	{
	delete header_;
	header_ = 0;
	}

int OPCUA_CREATE_SUBSCR_REQUEST::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, int t_byteorder)
	{
	// Checking out-of-bound for "OPCUA_CREATE_SUBSCR_REQUEST"
	if ( t_begin_of_data + (59) > t_end_of_data || t_begin_of_data + (59) < t_begin_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("OPCUA_CREATE_SUBSCR_REQUEST",
			(0) + (59), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "header"
	header_ = new REQUEST_HEADER();
	header_->Parse(t_begin_of_data, t_end_of_data, t_byteorder);
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "requested_publishing_interval"
	requested_publishing_interval_ = FixByteOrder(t_byteorder, *((uint64 const *) ((t_begin_of_data + 37))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "requested_lifetime_count"
	requested_lifetime_count_ = FixByteOrder(t_byteorder, *((uint32 const *) ((t_begin_of_data + 45))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "requested_max_keep_alive_count"
	requested_max_keep_alive_count_ = FixByteOrder(t_byteorder, *((uint32 const *) ((t_begin_of_data + 49))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "max_notifications_per_publish"
	max_notifications_per_publish_ = FixByteOrder(t_byteorder, *((uint32 const *) ((t_begin_of_data + 53))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "publishing_enabled"
	publishing_enabled_ = *((uint8 const *) ((t_begin_of_data + 57)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "priority"
	priority_ = *((uint8 const *) ((t_begin_of_data + 58)));
	// Evaluate 'let' and 'withinput' fields
	
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (59) <= t_end_of_data);
	return 59;
	}

OPCUA_CREATE_SUBSCR_RESPONSE::OPCUA_CREATE_SUBSCR_RESPONSE()
	{
	header_ = 0;
	revised_publishing_interval_ = 0;
	revised_lifetime_count_ = 0;
	revised_max_keep_alive_count_ = 0;
	}

OPCUA_CREATE_SUBSCR_RESPONSE::~OPCUA_CREATE_SUBSCR_RESPONSE()
	{
	delete header_;
	header_ = 0;
	}

int OPCUA_CREATE_SUBSCR_RESPONSE::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, int t_byteorder)
	{
	// Checking out-of-bound for "OPCUA_CREATE_SUBSCR_RESPONSE"
	if ( t_begin_of_data + (43) > t_end_of_data || t_begin_of_data + (43) < t_begin_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("OPCUA_CREATE_SUBSCR_RESPONSE",
			(0) + (43), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "header"
	header_ = new RESPONSE_HEADER();
	header_->Parse(t_begin_of_data, t_end_of_data, t_byteorder);
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "revised_publishing_interval"
	revised_publishing_interval_ = FixByteOrder(t_byteorder, *((uint64 const *) ((t_begin_of_data + 27))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "revised_lifetime_count"
	revised_lifetime_count_ = FixByteOrder(t_byteorder, *((uint32 const *) ((t_begin_of_data + 35))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "revised_max_keep_alive_count"
	revised_max_keep_alive_count_ = FixByteOrder(t_byteorder, *((uint32 const *) ((t_begin_of_data + 39))));
	// Evaluate 'let' and 'withinput' fields
	
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (43) <= t_end_of_data);
	return 43;
	}

OPCUA_GET_ENDPOINTS_REQUEST::OPCUA_GET_ENDPOINTS_REQUEST()
	{
	header_ = 0;
	end_point_url_ = 0;
	local_lelds_ = 0;
	profile_uris_ = 0;
	}

OPCUA_GET_ENDPOINTS_REQUEST::~OPCUA_GET_ENDPOINTS_REQUEST()
	{
	delete header_;
	header_ = 0;
	}

int OPCUA_GET_ENDPOINTS_REQUEST::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, int t_byteorder)
	{
	// Checking out-of-bound for "OPCUA_GET_ENDPOINTS_REQUEST"
	if ( t_begin_of_data + (57) > t_end_of_data || t_begin_of_data + (57) < t_begin_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("OPCUA_GET_ENDPOINTS_REQUEST",
			(0) + (57), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "header"
	header_ = new REQUEST_HEADER();
	header_->Parse(t_begin_of_data, t_end_of_data, t_byteorder);
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "end_point_url"
	end_point_url_ = FixByteOrder(t_byteorder, *((uint32 const *) ((t_begin_of_data + 37))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "local_lelds"
	local_lelds_ = FixByteOrder(t_byteorder, *((uint64 const *) ((t_begin_of_data + 41))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "profile_uris"
	profile_uris_ = FixByteOrder(t_byteorder, *((uint64 const *) ((t_begin_of_data + 49))));
	// Evaluate 'let' and 'withinput' fields
	
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (57) <= t_end_of_data);
	return 57;
	}

OPCUA_GET_ENDPOINTS_RESPONSE::OPCUA_GET_ENDPOINTS_RESPONSE()
	{
	header_ = 0;
	end_points_ = 0;
	}

OPCUA_GET_ENDPOINTS_RESPONSE::~OPCUA_GET_ENDPOINTS_RESPONSE()
	{
	delete header_;
	header_ = 0;
	}

int OPCUA_GET_ENDPOINTS_RESPONSE::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, int t_byteorder)
	{
	// Checking out-of-bound for "OPCUA_GET_ENDPOINTS_RESPONSE"
	if ( t_begin_of_data + (35) > t_end_of_data || t_begin_of_data + (35) < t_begin_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("OPCUA_GET_ENDPOINTS_RESPONSE",
			(0) + (35), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "header"
	header_ = new RESPONSE_HEADER();
	header_->Parse(t_begin_of_data, t_end_of_data, t_byteorder);
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "end_points"
	end_points_ = FixByteOrder(t_byteorder, *((uint64 const *) ((t_begin_of_data + 27))));
	// Evaluate 'let' and 'withinput' fields
	
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (35) <= t_end_of_data);
	return 35;
	}

NODE_ID::NODE_ID()
	{
	namespace_index_ = 0;
	type_id_ = 0;
	type_id__elem_ = 0;
	id_ = 0;
	}

NODE_ID::~NODE_ID()
	{
	delete type_id_;
	}

int NODE_ID::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, int t_byteorder)
	{
	// Checking out-of-bound for "NODE_ID"
	if ( t_begin_of_data + (10) > t_end_of_data || t_begin_of_data + (10) < t_begin_of_data )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("NODE_ID",
			(0) + (10), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "namespace_index"
	namespace_index_ = FixByteOrder(t_byteorder, *((uint32 const *) (t_begin_of_data)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "type_id"
	int t_type_id__arraylength;
	t_type_id__arraylength = 0;
	t_type_id__arraylength = 4;
	if ( t_begin_of_data + t_type_id__arraylength > t_end_of_data + 1 )
		{
		t_type_id__arraylength = t_end_of_data - t_begin_of_data + 1;
		}
	if ( t_type_id__arraylength < 0 )
		{
		t_type_id__arraylength = 0;
		}
	type_id__elem_ = 0;
	int t_type_id__elem__it;
	t_type_id__elem__it = 0;
	type_id_ = new vector<uint8>;
	type_id_->reserve(t_type_id__arraylength);
	const_byteptr t_type_id__elem__dataptr = (t_begin_of_data + 4);
	for (; t_type_id__elem__it < t_type_id__arraylength; ++t_type_id__elem__it)
		{
		// Check &until(type_id__elem__dataptr >= end_of_data)
		if ( t_type_id__elem__dataptr >= t_end_of_data )
			{
			goto end_of_type_id;
			}
		type_id__elem_ = *((uint8 const *) (t_type_id__elem__dataptr));
		// Evaluate 'let' and 'withinput' fields
		type_id_->push_back(type_id__elem_);
		t_type_id__elem__dataptr += 1;
		BINPAC_ASSERT(t_type_id__elem__dataptr <= t_end_of_data);
		}
end_of_type_id: ;
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "id"
	id_ = FixByteOrder(t_byteorder, *((uint16 const *) ((t_begin_of_data + 8))));
	// Evaluate 'let' and 'withinput' fields
	
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (10) <= t_end_of_data);
	return 10;
	}

namespace OPCUA {
ContextOPCUA::ContextOPCUA(OPCUA_Conn * connection, OPCUA_Flow * flow)
	{
	connection_ = connection;
	flow_ = flow;
	}

ContextOPCUA::~ContextOPCUA()
	{
	}

OPCUA_Conn::OPCUA_Conn(BroAnalyzer const & bro_analyzer)
	{
	upflow_ = new OPCUA_Flow(this, true);
	downflow_ = new OPCUA_Flow(this, false);
	bro_analyzer_ = bro_analyzer;
	}

OPCUA_Conn::~OPCUA_Conn()
	{
	delete upflow_;
	upflow_ = 0;
	delete downflow_;
	downflow_ = 0;
	}

void OPCUA_Conn::NewData(bool is_orig, const_byteptr begin, const_byteptr end)
	{
	if ( is_orig )
		upflow_->NewData(begin, end);
	else
		downflow_->NewData(begin, end);
	}

void OPCUA_Conn::NewGap(bool is_orig, int gap_length)
	{
	if ( is_orig )
		upflow_->NewGap(gap_length);
	else
		downflow_->NewGap(gap_length);
	}

void OPCUA_Conn::FlowEOF(bool is_orig)
	{
	if ( is_orig )
		upflow_->FlowEOF();
	else
		downflow_->FlowEOF();
	}

OPCUA_Flow::OPCUA_Flow(OPCUA_Conn * connection, bool is_orig)
	{
	connection_ = connection;
	is_orig_ = is_orig;
	dataunit_ = 0;
	context_ = 0;
	}

OPCUA_Flow::~OPCUA_Flow()
	{
	delete dataunit_;
	dataunit_ = 0;
	delete context_;
	context_ = 0;
	}

void OPCUA_Flow::NewData(const_byteptr t_begin_of_data, const_byteptr t_end_of_data)
	{
	try
		{
		dataunit_ = new OPCUA_PDU(is_orig());
		context_ = new ContextOPCUA(connection(), this);
		int t_dataunit__size;
		t_dataunit__size = dataunit_->Parse(t_begin_of_data, t_end_of_data);
		// Evaluate 'let' and 'withinput' fields
		delete dataunit_;
		dataunit_ = 0;
		delete context_;
		context_ = 0;
		}
	catch ( binpac::Exception const &e )
		{
		delete dataunit_;
		dataunit_ = 0;
		delete context_;
		context_ = 0;
		throw;
		}
	}

void OPCUA_Flow::NewGap(int gap_length)
	{
	}
void OPCUA_Flow::FlowEOF()
	{
	}
} // namespace OPCUA
}  // namespace binpac
