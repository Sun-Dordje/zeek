##! Implements base functionality for OPCUA analysis.
##! Generates the Opcua.log file.

# Generated by binpac_quickstart

module Opcua;

type requests_types: enum {_OPEN_SECURE_CHANNEL_REQUEST, _CLOSE_SECURE_CHANNEL_REQUEST, _PUBLISH_REQUEST, _BROWSE_REQUEST, _READ_REQUEST, _WRITE_REQUEST, _CREATE_SUBSCR_REQUEST, _GET_ENDPOINTS_REQUEST, _CREATE_MONITORED_ITEMS_REQUEST, _CREATE_SESSION_REQUEST, _ACTIVATE_SESSION_REQUEST, _TRANSLATE_BROWSE_PATH_TO_NODE_IDS_REQUEST, _UNDEFINED_REQ};

type responses_types: enum {_OPEN_SECURE_CHANNEL_RESPONSE,_CLOSE_SECURE_CHANNEL_RESPONSE, _PUBLISH_RESPONSE, _BROWSE_RESPONSE, _READ_RESPONSE, _WRITE_RESPONSE, _CREATE_SUBSCR_RESPONSE, _GET_ENDPOINTS_RESPONSE, _CREATE_MONITORED_ITEMS_RESPONSE, _CREATE_SESSION_RESPONSE, _ACTIVATE_SESSION_RESPONSE, _TRANSLATE_BROWSE_PATH_TO_NODE_IDS_RESPONSE, _UNDEFINED_RES};

#keeps max sequence number received per each connections
global max_sequence_number: table[conn_id] of count;

#for each request id, keeps track if request has been reveived F or req et resp T
global request_numbers: table[conn_id] of table[count] of bool;

#tracks requests Types
global requests: table[conn_id] of table[count] of requests_types;

#tracks responses Types
global responses: table[conn_id] of table[count] of responses_types;

function get_request_type(req: count): requests_types{
	local val: requests_types= _UNDEFINED_REQ;
	switch ( req ){
			 case 428:
					 val = _GET_ENDPOINTS_REQUEST;
					 break;
			 case 446:
					 val = _OPEN_SECURE_CHANNEL_REQUEST;
					 break;
			 case 450:
					 val = _CLOSE_SECURE_CHANNEL_REQUEST;
					 break;
			 case 525:
			 		 val = _BROWSE_REQUEST;
					 break;
			 case 629:
					 val = _READ_REQUEST;
					 break;
			 case 671:
					 val = _WRITE_REQUEST;
					 break;
			 case 785:
					 val = _CREATE_SUBSCR_REQUEST;
					 break;
			 case 824:
					 print _PUBLISH_REQUEST;
					 break;
		}
		return val;
}

function get_response_type(req: count): requests_types{
	local val: responses_types= _UNDEFINED_REQ;
	switch ( req ){
			 case 431:
					 val = _GET_ENDPOINTS_RESPONSE;
					 break;
			 case 449:
					 val = _OPEN_SECURE_CHANNEL_RESPONSE;
					 break;
			 case 453:
					 val = _CLOSE_SECURE_CHANNEL_RESPONSE;
					 break;
			 case 528:
			 		 val = _BROWSE_RESPONSE;
					 break;
			 case 632:
					 val = _READ_RESPONSE;
					 break;
			 case 674:
					 val = _WRITE_RESPONSE;
					 break;
			 case 788:
					 val = _CREATE_SUBSCR_RESPONSE;
					 break;
			 case 827:
					 print _PUBLISH_RESPONSE;
					 break;
		}
		return val;
}

export {
	redef enum Log::ID += { LOG };

	type Info: record {
		## Timestamp for when the event happened.
		ts:     time    &log;
		## Unique ID for the connection.
		##uid:    string  &log;
		## The connection's 4-tuple of endpoint addresses/ports.
		id:     conn_id &log;

		# ## TODO: Add other fields here that you'd like to log.
	};
	redef record connection += {
    # By convention, the name of this new field is the lowercase name
    # of the module.
    opcua: Info &optional;
};
	## Event that can be handled to access the OPCUA record as it is sent on
	## to the loggin framework.
	global log_opcua: event(rec: Info);
}

# TODO: The recommended method to do dynamic protocol detection
# (DPD) is with the signatures in dpd.sig. If you can't come up
# with any signatures, then you can do portbased detection by
# uncommenting the following and specifying the port(s):

# const ports = { 1234/tcp, 5678/tcp };


# redef likely_server_ports += { ports };

event bro_init()
	{
	Log::create_stream(Opcua::LOG, [$columns=Info, $path="opcua"]);

	print "OPC UA POLICY SCRIPT INIT DUDDDDE";

	# TODO: If you're using port-based DPD, uncomment this.
	# Analyzer::register_for_ports(Analyzer::ANALYZER_OPCUA, ports);
	}

event bro_done()
	{
	print "TERMINATE BRO SCRIPT, CHECK IF EACH REQUEST HAD A RESPONSE....";

	for(k in request_numbers){
		for(kk in request_numbers[k]){
			if(request_numbers[k][kk]==F){
				print fmt("request %d has no response",kk);
			}
		}
	}
	}

event opcua_event(c: connection,chunk_type:count, message_size: count)
	{
	print fmt("got OOOOOOH OPC UA PDU, chunk_type: %d, message_size: %d", chunk_type, message_size);
	#Log::write(Opcua::LOG, info);
	delete max_sequence_number[c$id];
	delete request_numbers[c$id];
	}

	global local_subnets: set[subnet] = { 127.0.0.0/8 };
	global my_count = 0;
	global inside_networks: set[addr];
	global outside_networks: set[addr];

event new_connection(c: connection)
    {
    ++my_count;
    if ( my_count <= 10 )
	{
        print fmt("The connection %s from %s on port %s to %s on port %s started at %s.", c$uid, c$id$orig_h, c$id$orig_p, c$id$resp_h, c$id$resp_p, strftime("%D %H:%M", c$start_time));
    }
    if ( c$id$orig_h in local_subnets)
    	{
	add inside_networks[c$id$orig_h];
        }
    else
        add outside_networks[c$id$orig_h];

    if ( c$id$resp_h in local_subnets)
        {
        add inside_networks[c$id$resp_h];
        }
    else
        add outside_networks[c$id$resp_h];
    }

event connection_state_remove(c: connection)
    {
    if ( my_count <= 10 )
    	{
    	print fmt("Connection %s took %s seconds", c$uid, c$duration);
    	}
    }

event opcua_hello_event(c: connection, params: OPCUA::connection_parameters, end_point_url: string)
	{

	local rec: Opcua::Info = [$ts=network_time(), $id=c$id];

    # Store a copy of the data in the connection record so other
    # event handlers can access it.
    #c$id = rec;

  Log::write(Opcua::LOG, rec);
	print fmt("GOOOOOOOOOOOOT OPC UA hello, version: %d, receive_buffer_size: %d, send_buffer_size: %d, max_msg_size: %d, max_chunk_count: %d, end_point_url: %s", params$version, params$receive_buffer_size, params$send_buffer_size, params$max_msg_size,params$max_chunk_count, end_point_url);

	}

event opcua_ack_event(c: connection, params: OPCUA::connection_parameters)
	{
	print fmt("got OPC UA ack, version: %d, receive_buffer_size: %d, send_buffer_size: %d, max_msg_size: %d, max_chunk_count: %d", params$version, params$receive_buffer_size, params$send_buffer_size,	params$max_msg_size, params$max_chunk_count);
	}

event opcua_open_event(c:connection, secure_channel_id: count, security_policy_uri: string, sender_certificate: count, receiver_certificate_thumbprint: count, sequence_number: count, request_id: count)
	{
	print fmt("got OPC UA open, secure_channel_id: %d, security_policy_uri: %s, sender_certificate: %d, receiver_certificate_thumbprint: %d, sequence_number: %d, request_id: %d ", secure_channel_id, security_policy_uri, sender_certificate, receiver_certificate_thumbprint, sequence_number,request_id);
	}

event opcua_close_event(c:connection)
	{
	print "gotanOPCUAClose";
	}

#CHECK EACH MSG message to verify validity of sequence_number
event opcua_message_event(c: connection, params: OPCUA::security_params, type_id: count)
	{
	print fmt("Got OPC UA MESSAGE type_id: %x, secure_channel_id: %d, security_token_id: %d,security_sequence_number: %d, security_request_id: %d", type_id, params$security_channel_id, params$security_token_id , params$security_sequence_number ,params$security_request_id);

	#if first message for this connection, init record in table
	if( c$id in max_sequence_number && (params$security_sequence_number > max_sequence_number[c$id] )){
				print fmt("invalid sequence_number: request: %s, response: %s, [%d], request id [%d] detected on %s", (params$security_request_id in requests[c$id] ? requests[c$id][params$security_request_id]: _UNDEFINED_REQ), (params$security_request_id in responses[c$id]) ? responses[c$id][params$security_request_id] : _UNDEFINED_RES , params$security_sequence_number, params$security_request_id, c$id);
			}

	if( c$id !in request_numbers){
		request_numbers[c$id]=table();
	}

	#if request_id has never been received for this connection, this is a request
	if ([params$security_request_id] !in request_numbers[c$id]){
		request_numbers[c$id][params$security_request_id] = F;
		local _t: requests_types= get_request_type(type_id);
		if(_t != _UNDEFINED_REQ){
			if(c$id !in requests){
				requests[c$id]=table();
			}
			requests[c$id][params$security_request_id] = _t;
		}
		else{
		local _tt: responses_types= get_response_type(type_id);
		if(c$id !in responses){
			responses[c$id]=table();
		}
		responses[c$id][params$security_request_id] = _tt;
		print fmt("WEIRD, a request was expected but is a response %s", _tt);
		}

		#if the request has no valid sequence_number, error
		if (c$id in max_sequence_number && params$security_sequence_number != max_sequence_number[c$id] + 1){
			print fmt("invalid sequence_number: request: %s, response: %s, [%d], request id [%d] detected on %s", (params$security_request_id in requests[c$id] ? requests[c$id][params$security_request_id]: _UNDEFINED_REQ), (params$security_request_id in responses[c$id]) ? responses[c$id][params$security_request_id] : _UNDEFINED_RES , params$security_sequence_number, params$security_request_id, c$id);
		}

		#otherwise , update the max_sequence_number for this connection
		else if (!(c$id in max_sequence_number) || params$security_sequence_number > max_sequence_number[c$id] ){
			max_sequence_number[c$id] = params$security_sequence_number;
		}
		print fmt("%d %d max : %d", params$security_request_id, params$security_sequence_number, max_sequence_number[c$id]);
	}

	#otherwisen check if a response has been already received, if yes throw error
	else if(request_numbers[c$id][params$security_request_id] == T ){
		print fmt("invalid sequence_number: request: %s, response: %s, [%d], request id[%d] detected on %s", (params$security_request_id in requests[c$id]) ? requests[c$id][params$security_request_id] : _UNDEFINED_REQ, (params$security_request_id in responses[c$id]) ? responses[c$id][params$security_request_id] : _UNDEFINED_RES, params$security_sequence_number, params$security_request_id, c$id);
	}

	#otherwise, this is a potentially valid responses
	else{
		print fmt("%d %d max : %d", params$security_request_id ,params$security_sequence_number, max_sequence_number[c$id]);
		request_numbers[c$id][params$security_request_id] = T;

		#update tracking of request/response pair
		local t: responses_types=get_response_type(type_id);
		if(t != _UNDEFINED_RES){
			if(c$id !in responses){
				responses[c$id]= table();
			}
			responses[c$id][params$security_request_id] = t;
		}
		else{
			local tt: requests_types=get_request_type(type_id);
			if (c$id !in requests){
				requests[c$id] = table();
			}
			requests[c$id][params$security_request_id] = tt;
			print fmt("Weird, a request was expected but is a response %s", tt);
		}

		#response should bring a sequence_number that is smaller than the maximum sequence_number transmitted
			if( c$id in max_sequence_number && (params$security_sequence_number > max_sequence_number[c$id] )){
				print fmt("invalid sequence_number: request: %s, response: %s, [%d], request id [%d] detected on %s", (params$security_request_id in requests[c$id] ? requests[c$id][params$security_request_id]: _UNDEFINED_REQ), (params$security_request_id in responses[c$id]) ? responses[c$id][params$security_request_id] : _UNDEFINED_RES , params$security_sequence_number, params$security_request_id, c$id);
			}
		}
	}

event opcua_open_secure_channel_request_event(c: connection, header: OPCUA::request_header, client_protocol_version: count, security_token_request_type: count, message_security_mode:count, client_nonce: string)
	{
	print fmt("open secure channel request, client_protocol_version: %d, security_token_request_type: %d, message_security_mode: %d, client_nonce: %s−−−−−%s", client_protocol_version ,security_token_request_type , message_security_mode, client_nonce, strftime("%D%R",header$timestamp));
	}

event opcua_open_secure_channel_response_event(c:connection, header: OPCUA::response_header, server_protocol_version:count, st: OPCUA::security_token,server_nonce:string)
	{
	print fmt("secure channel open response−server_nonce: %s−timestamp: %s", server_nonce, strftime("%D%R",header$timestamp));
	}

event opcua_browse_request(c:connection, header: OPCUA::request_header, view: OPCUA::view, nodes: OPCUA::browse_description_vector,request_max_references_per_node:count)
	{
	local rec: Opcua::Info = [$ts=network_time(), $id=c$id];

		# Store a copy of the data in the connection record so other
		# event handlers can access it.
		#c$id = rec;

	Log::write(Opcua::LOG, rec);
	print fmt("browse reques tof %d elements−request_max_references_per_node: %d", |nodes|,request_max_references_per_node);
	local i=0;
	while(i<|nodes|){
		print fmt("node_id: %d, reference_type_id: %d, include_subtype: %d, node_class_mask: %d, result_mask: %d", nodes[i]$node_id$encoding_mask, nodes[i]$reference_type_id$encoding_mask, nodes[i]$include_subtype, nodes[i]$node_class_mask, nodes[i]$result_mask);
		i+=1;
		}
	}

event opcua_browse_response(c:connection, header: OPCUA::response_header, results: OPCUA::browse_result_vector,  diagnostics_info:count)
	{
	print fmt("browse response of %d elements",|results|);
	local i=0;
	while(i<|results|){
		print fmt("status_code: %d, continuation_point: %d, references: %d",
		results[i]$status_code,results[i]$continuation_point,|results[i]$references|);
		local j=0;
		while(j<|results[i]$references|){
			print fmt("reference_type_id:%d,is_forward%d",results[i]
			$references[j]$reference_type_id$encoding_mask,results[i]
			$references[j]$is_forward);
			j+=1;
		}
		i+=1;
	}
	}

event opcua_read_request(c:connection,header: OPCUA::request_header,max_age:count, timestamp_to_return:count,nodes_to_read: OPCUA::read_vector)
	{
	print fmt("read request of %d elements, max_age: %d, timestamp_to_return: %d", |nodes_to_read|,max_age,timestamp_to_return);
	}

event opcua_read_response(c:connection, header: OPCUA::response_header,results: OPCUA::data_value_vector)
	{
	print fmt("readresponseof%delements",|results|);
	local i=0;
	while(i<|results|){
		print fmt("encoding_mask:%d,variant_type:%d",results[i]
		$encoding_mask,results[i]$variant_type);
		i+=1;
	}
	}

event opcua_write_request(c:connection)
	{
	print"writerequest";
	}

event opcua_write_response(c:connection)
	{
	print"writeresponse";
	}

event opcua_publish_request(c:connection,header: OPCUA::request_header)
	{
	print"publishrequest";
	}

event opcua_publish_response(c:connection, header: OPCUA::response_header,subscription_id: count,more_notifications:bool,notification :OPCUA::notification)
	{
	print fmt("publishresponse−subscription_id:%d",subscription_id);
	}

event opcua_create_subscr_request(c:connection,header:OPCUA::request_header, publishing_interval:count,lifetime_count:count,max_keep_alive_count:count, max_notifications_per_publish:count,publishing_enable:bool,priority:count)
	{
	print"subscriptionrequest";
	}

event opcua_create_subscr_response(c:connection, header: OPCUA::response_header, subscription_id: count, revised_publishing_interval: count, revised_lifetime_count: count, revised_max_keep_alive_count: count)
	{
	print fmt("subscription response, revised_lifetime_count: %d",revised_lifetime_count);
	}

event opcua_get_endpoints_request(c: connection, header: OPCUA::request_header, endpoint_url: string, locale_ids: OPCUA::string_vector, profile_uris: OPCUA::string_vector)
	{
	print fmt("got end points request−endpoint_url:%s",endpoint_url);
	local i=0;
	while(i<|locale_ids|){
		print fmt("[%d]=%s",i,locale_ids[i]);
		i+=1;
		}
	}

event opcua_get_endpoints_response(c: connection, header: OPCUA::response_header, endpoints: OPCUA::endpoint_description_vector)
	{
	print"got end points response";
	}
